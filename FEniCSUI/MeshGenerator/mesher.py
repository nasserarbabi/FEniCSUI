'''
functions for meshing with GMESH
'''
import os
import time
import numpy
import json
import copy
import itertools as itr


class gmsh():
    def __init__(self, analysisId):
        self.analysisId = analysisId
        self.stepFile = os.path.abspath(
            "./media/{}".format(analysisId))+'/stepFile.step'
        self.edgeMeshFile = os.path.abspath(
            "./media/{}".format(analysisId))+'/visualizationEdgeMesh.msh'
        self.mesh = os.path.abspath(
            "./media/{}".format(analysisId))+'/mesh.msh'
        self.points = []

    def visualizationEdgeMesh(self):
        '''
        mesh the edges of the geometry and save the result
        output:
            file:: "visualizationEdgeMesh.msh" visualizationEdgeMesh.msh containing edge meshes
            JSON:: "edges" a dictionary containing edge numbers and their mesh
        '''
        # remove previous file if exist
        if os.path.exists(self.edgeMeshFile):
            os.system("rm {}".format(self.edgeMeshFile))
        if os.path.exists(self.edgeMeshFile):
            os.system("rm {}".format(self.stepFile))

        os.system(
            """gmsh -string "Geometry.OCCSewFaces = 1;" {} -clcurv 50 -clscale 0.4 -o {} -1 """.format(self.stepFile, self.edgeMeshFile))

        for i in range(10):  # check if the mesh is generated
            if os.path.exists(self.edgeMeshFile):
                break
            time.sleep(3)

        with open(self.edgeMeshFile, "r") as f:
            f.readline()  # '$MeshFormat\n'
            f.readline()  # '2.2 0 8\n'
            f.readline()  # '$EndMeshFormat\n'
            f.readline()  # '$Nodes\n'
            n_nodes = int(f.readline())  # number of nodes
            nodes = numpy.fromfile(
                f, count=n_nodes*4, sep=" ").reshape((n_nodes, 4))
            nodes[:, 1:4] /= 1000  # scaling
            f.readline()  # '$EndNodes\n'
            f.readline()  # '$Elements\n'
            n_elems = int(f.readline())  # '2\n'
            points = []
            edges = {}
            for i in range(n_elems):
                line = f.readline().split()
                if len(line) < 2:
                    break
                if line[1] == "15":  # element type of 15 is a point
                    points.extend(nodes[int(line[4])-1][1:4])
                elif line[1] == "1":  # element type of 2 is a line
                    if line[4] not in edges.keys():
                        edges[line[4]] = []

                    edges[line[4]].extend(nodes[int(line[5])-1, 1:4])
                    edges[line[4]].extend(nodes[int(line[6])-1, 1:4])

            self.points = points
        return json.dumps(edges)

    def visualizationPoints(self):
        '''
        this returns the points of the initial cad file
        should be called after visualizationEdgeMesh() in this version
        will be replaced by a more robust version of mesh file reader
        output:
            JSON:: "points" a dictionary containing points of initial cad file
        '''
        return json.dumps(self.points)

    def generateMesh(self, meshSize):
        os.system(
            """gmsh -string "Geometry.OCCSewFaces = 1;" {} -clcurv 50 -clscale {} -o {} -2 """.format(self.stepFile, meshSize, self.mesh))

        for i in range(10):  # check if the mesh is generated
            if os.path.exists(self.mesh):
                break
            time.sleep(3)


class mshReader():
    ''' 
    class for reading msh file generated by Gmsh

    '''

    def __init__(self, analysisId):
        self.path = os.path.abspath(
            "./media/{}".format(analysisId))+'/mesh.msh'
        self.nodes = []
        self.connectivity = []
        self.faces = {}
        self.edges = {}
        self.points = {}
        self.mesh = self.readFile()
        self.bufferedMesh = self.convertBufferedMesh()

    def readFile(self):
        with open(self.path, "r") as f:
            f.readline()  # '$MeshFormat\n'
            f.readline()  # '2.2 0 8\n'
            f.readline()  # '$EndMeshFormat\n'
            f.readline()  # '$Nodes\n'
            n_nodes = int(f.readline())  # number of nodes
            self.nodes = numpy.fromfile(
                f, count=n_nodes*4, sep=" ").reshape((n_nodes, 4))
            self.nodes[:, 1:4] /= 1000  # scaling
            # nodes are stored as array, so node No 1 is array[0]
            self.nodes = numpy.delete(self.nodes, 0, 1)

            f.readline()  # '$EndNodes\n'
            f.readline()  # '$Elements\n'
            n_elems = int(f.readline())  # '2\n'
            for i in range(n_elems):
                line = f.readline().split()
                if line[1] == "15":  # element type of 15 is a point
                    self.points[line[4]] = int(line[4])

                elif line[1] == "1":  # element type of 2 is a line
                    if line[4] not in self.edges.keys():
                        self.edges[line[4]] = []
                    self.edges[line[4]].append([int(line[5]), int(line[6])])

                elif line[1] == "2":  # element type of 2 is a triangle
                    if line[4] not in self.faces.keys():
                        self.faces[line[4]] = []
                    self.faces[line[4]].append(
                        [int(line[5]), int(line[6]), int(line[7])])
                    self.connectivity.append(
                        [int(line[5]), int(line[6]), int(line[7])])
        mesh = {
            "nodes": self.nodes.tolist(),
            "connectivity": self.connectivity,
            "faces": self.faces,
            "edges": self.edges,
            "points": self.points
        }
        return json.dumps(mesh)

    def convertBufferedMesh(self):
        ''' this function converts the mesh to buffered geometry'''
        bufferedFaces = copy.deepcopy(self.faces)
        bufferedEdges = copy.deepcopy(self.edges)
        bufferedPoints = copy.deepcopy(self.points)

        for face in bufferedFaces.keys():
            bufferedFaces[face] = [self.nodes[values[x]-1].tolist()
                                   for values in self.faces[face] for x in range(3)]
            bufferedFaces[face] = list(itr.chain(*bufferedFaces[face]))

        for edge in bufferedEdges.keys():
            bufferedEdges[edge] = [self.nodes[values[x]-1].tolist()
                                   for values in self.edges[edge] for x in range(2)]
            bufferedEdges[edge] = list(itr.chain(*bufferedEdges[edge]))

        for point in bufferedPoints.keys():
            bufferedPoints[point] = [self.nodes[self.points[point]-1].tolist()]
            bufferedPoints[point] = list(itr.chain(*bufferedPoints[point]))

        # finiding bounding box
        lowX = 0
        lowY = 0
        lowZ = 0
        highX = 0
        highY = 0
        highZ = 0
        for node in self.nodes:
            if node[0] < lowX: lowX = node[0] 
            if node[1] < lowY: lowY = node[1] 
            if node[2] < lowZ: lowZ = node[2] 
            if node[0] > highX: highX = node[0]
            if node[1] > highY: highY = node[1]
            if node[2] > highZ: highZ = node[2]
        return json.dumps(
            {
                "faces": bufferedFaces,
                "edges": bufferedEdges,
                "points": bufferedPoints,
                "boundingBox": {
                    "lowX": lowX,
                    "lowY": lowY,
                    "lowZ": lowZ,
                    "highX": highX,
                    "highY": highY,
                    "highZ": highZ,
                }
            }
        )


if __name__ == "__main__":
    part = mshReader("1")
    api_gmsh.initialize()
